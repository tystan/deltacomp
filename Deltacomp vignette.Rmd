---
title: "Introduction to deltacomp"
author: "Ty Stanford, Charlotte Lund Rasmussen, Dorothea Dumuid"
date: "`r Sys.Date()`"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{Vignette Title}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r setup, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>"
)
```

The goal of deltacomp is to provide ready-to-use functions enabling analysis of compositional data and produce predictions for relative increases and decreases in the compositional parts. 

In the following, we provide examples of how to use the package functions `XX` and `XX`, provided in the package.


## 1. Background: compositional isotemporal substitution analysis

For an outcome variable Y, D compositional parts (x_1, ..., x_D) and C covariates (z_1, ..., z_C); this package fits the compositional data analysis model (notation inexact):

Y = b_0 + b_1 ilr_1 + ... + b_{D-1} ilr_{D-1} + a_1 z_1 + ... + a_C z_C + e

where ilr_i are the D-1 isometric log ratio variables derived from the D compositional parts (x_1, ..., x_D), b_0, ..., b_{D-1}, a_1, ..., a_C are D+C parameters to be estimated and e ~ N(0, sigma) is the error. The package then makes predictions in alterations of the compositional variables (the linearly dependent set of compositional parts) based on this model.


For a starting point to learn about compositional data analysis please see [Aitchison (1982)](https://doi.org/10.1111/j.2517-6161.1982.tb01195.x) or [van den Boogaart and Tolosana-Delgado (2013)](https://link.springer.com/book/10.1007%2F978-3-642-36809-7). 

However the articles [Dumuid et al. (2017a)](https://doi.org/10.1177/0962280217710835), [Dumuid et al. (2017b)](https://doi.org/10.1177%2F0962280217737805), and [Dumuid et al. (2020)](https://doi.org/10.3390/ijerph17072220) may be more approachable introductions both to compositional data analysis and compositional isotemporal substitution analysis.


## 2. Datasets in package

Two datasets are supplied with the package:

* `fairclough` and 
* `fat_data`.

The `fairclough` dataset was kindly provided by the authors of [Fairclough et al. (2017)](https://doi.org/10.1186/s12966-017-0521-z). `fat_data` is a randomly generated test dataset that might roughly mimic a real dataset.

## 3. Options for reallocating of time between compositional parts

The deltacomp package enables either one-to-remaining or one-to-one reallocation between the compositional parts. Both types of time-use reallocations are done proportionally. 

One-from-remaining reallocation allows for time-use exchange between one compositional part and the remaining compositional parts. In the `predict_delta_comps` function, this type of reallocation is chosen when using the `comparisons = "prop-realloc"` option. 
For a detailed description of one-to-remaining time-use reallocation,  please see [Dumuid et al. (2017a)](https://doi.org/10.1177/0962280217710835)

One-to-one reallocation enables time-use exchange between two compositional parts. Note that this reallocation can be done independent of the number of parts in the composition.  This type of reallocation is chosen when using the `comparisons = "one-v-one"` option of the `predict_delta_comps()` function. 
For a detailed description of one-to-one time-use reallocation,  please see 
[Dumuid et al. (2017b)](https://doi.org/10.1177%2F0962280217737805).

### 3.1. Example of one-from-remaning realloction (`comparisons = "prop-realloc"` option)

Suppose you have 3-part composition summing to 1 (e.g. a day) to predict an outcome variable. The three compositonal parts are time spent `active` `sedentary`, and `sleeping`. Let's assume the mean sampled composition is:

* `active = 0.2` (i.e., 20% a day)
* `sedentary = 0.5` (i.e., 50% a day)
* `sleeping = 0.3`  (i.e., 30% a day)

If you wanted to predict the change in the outcome variable from the above mean composition when `delta = +0.05` (5% of the day) is added to `sedentary`, the option `comparisons = "prop-realloc"` reduces the remaining parts by the 5% proportionately based on their mean values, illustrated below:

* `sedentary* = 0.5 + delta = 0.5 + 0.05 = 0.55`
* `active* = 0.2 - delta * active / (sleeping + active) = 0.2 - 0.05 * 0.2 / (0.3 + 0.2) = 0.2 - 0.02 = 0.18`
* `sleeping* = 0.3 - delta * sleeping / (sleeping + active) = 0.3 - 0.05 * 0.3 / (0.3 + 0.2) = 0.3 - 0.03 = 0.27`

By reducing the parts with 5% proportionally, the new composition still sums to 1: `sedentary* + active* + sleeping*  = 0.55 + 0.18 + 0.27 = 1`.

Of note, in the example above, the option `comparisons = "prop-realloc"` in `predict_delta_comps()` will automatically produce separate predictions for a `delta = +0.05` on each of the parts against the remaining parts. I.e. not only the `sedentary* = 0.5 + delta` scenario as illustrated above but also `sleep* = 0.3 + delta` and `active* = 0.2 + delta` cases.

### 3.2. Example of one-to-one realloction (`comparisons = "one-v-one"` option)

Similarily to the previous example, suppose you have 3-part composition summing to 1 (e.g. a day) to predict an outcome variable. The three compositonal parts are time spent `active` `sedentary`, and `sleeping`. Let's assume the mean sampled composition is:

* `active = 0.2` (i.e., 20% a day)
* `sedentary = 0.5` (i.e., 50% a day)
* `sleeping = 0.3`  (i.e., 30% a day)

If you wanted to predict the change in the outcome variable from the above mean composition with `delta = +0.05` (5% of the day), the option `comparisons = "one-v-one"` looks at all pairwise exchanges between the parts `(sedentary*, sleeping*, active*)`:

* `(0.5 + 0.05, 0.3 - 0.05, 0.2       )`
* `(0.5 + 0.05, 0.3       , 0.2 - 0.05)`
* `(0.5       , 0.3 + 0.05, 0.2 - 0.05)`
* `(0.5 - 0.05, 0.3 + 0.05, 0.2       )`
* `(0.5 - 0.05, 0.3       , 0.2 + 0.05)`
* `(0.5       , 0.3 - 0.05, 0.2 + 0.05)`


## 4. Example usage

```{r}

library(devtools) # see https://www.r-project.org/nosvn/pandoc/devtools.html
devtools::install_github('tystan/deltacomp')
library(deltacomp)
### see help file to run example
?predict_delta_comps

#example of one-from-remaining reallocation

predict_delta_comps(
    dataf = fat_data,
    y = "fat",
    comps = c("sl", "sb", "lpa", "mvpa"),
    covars = c("sibs", "parents", "ed"),
    deltas = seq(-60, 60, by = 5) / (24 * 60),
    comparisons = "prop-realloc",
    alpha = 0.05
)


#example of one-to-one reallocation

predict_delta_comps(
    dataf = fat_data,
    y = "fat",
    comps = c("sl", "sb", "lpa", "mvpa"),
    covars = c("sibs", "parents", "ed"),
    deltas = seq(-60, 60, by = 5) / (24 * 60),
    comparisons = "one-v-one",
    alpha = 0.05
)
```


## 5. Output and plotting results

Output is a `data.frame` that can be turned into the plot below using the following code.

```{r}

pred_df <- 
    predict_delta_comps(
        dataf = fairclough,
        y = "z_bmi",
        comps = c("sleep", "sed", "lpa", "mvpa"),
        covars = c("decimal_age", "sex"),
        # careful deltas greater than 25 min in magnitude induce negative compositions
        # predict_delta_comps() will warn you about this :-)
        deltas =  seq(-20, 20, by = 5) / (24 * 60), 
        comparisons = "prop-realloc", # or try "one-v-one"
        alpha = 0.05
    )

plot_delta_comp(
    pred_df, # provide the returned object from predict_delta_comps()
    # x-axis can be converted from propotion of composition to meaningful units
    comp_total = 24 * 60, # minutes available in the composition
    units_lab = "min" # just a label for plotting
)
```


### 5.1. Prediction for the mean composition

The function `predict_delta_comps()` now outputs the predicted outcome value (with `100 * (1 - alpha)`% confidence interval). This data is printed to the console but also can be extracted from the output of `predict_delta_comps()` as per the below code:

```{r}
# produces a 1 line data.frame that contains 
#    the (simplex/geometric) mean composition,
#    the "average" covariates (the median of the factor variables in order of the levels are taken as default),
#    the ilr coords of the (simplex/geometric) mean composition, and
#    the predicted outcome value with 100*(1-alpha)% confidence interval
attr(pred_df, "mean_pred")


```


